/*
This test case asserts that Sorald doesn't remove a variable declaration whose initializer is
a dead store, if that variable is later used.
 */

public class DeadStoreInitializer {

    /**
     * A dead store that is directly succeded by another assignment.
     */
    public int deadStoreOnInitializer() {
        int a = 3;
        return a;
    }

    /**
     * A dead store where the next assignment is far removed in a nested block.
     */
    public int deadStoreOnInitializerWithVariableUsedInNestedBlock(int a, int b) {

        if (a < b) {
            return a;
        } else {
            if (b < a) {
                return b;
            } else {
                int c = a + b;
                return c;
            }
        }
    }

    /**
     * A dead store in the initializer where there are multiple assignments and reads in
     * different code paths. The goal here is to find the shallowest block in commin and
     * declare the variable there.
     */
    public int deadStoreOnInitializerWithVariableUsedInDifferentCodePaths(int a, int b) {

        if (a < b) {
            int c;
            if (b < a) {
                if (a + b < 2) {
                    c = a + b;
                } else {
                    c = a - b;
                }
                System.out.println(c);
            } else {
                c = 2;
                System.out.println(c);
            }
        }
    }

    /**
     * A dead store in the initializer where there are multiple assignments and reads in
     * different code paths. The goal here is to find the deepest block in common and
     * declare the variable there.
     */
    public int deadStoreOnInitializerWithVariableUsedInDifferentCodePaths2(int a, int b) {

        if (a < b) {
            int c = 22;
            if (b < a) {
                if (a + b < 2) {
                    c = a + b;
                } else {
                    c = a - b;
                }
                System.out.println(c);
            } else {
                System.out.println(c);
            }
        }
    }
}