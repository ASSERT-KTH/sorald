package sorald.processor;

import java.util.List;
import java.util.Set;
import sorald.annotations.IncompleteProcessor;
import sorald.annotations.ProcessorAnnotation;
import spoon.reflect.declaration.CtClass;
import spoon.reflect.declaration.CtConstructor;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.ModifierKind;

/**
 * This repair targets classes that only have static members (_utility classes_)
 * and a public constructor, which they should not have according to the rule.
 * This repair only targets the case when there is an _implicit_ public
 * constructor, the so-called _default_ constructor, which is generated by the
 * compiler when no constructor is specified. The repair simply consists of adding
 * a private, no-args constructor at the top of the class.
 *
 * ```diff
 *  public class UtilityClassWithoutConstructor {
 * +    private UtilityClassWithoutConstructor() {
 * +    }
 *      public static final int SOME_CONSTANT = 42;
 *  }
 * ```
 *
 * > **Important:** The repair does not attempt to do anything if there is an
 * > explicit public constructor.
 */
@IncompleteProcessor(description = "Only handles implicit public constructor")
@ProcessorAnnotation(
        key = "S1118",
        description = "Utility classes should not have public constructors")
public class UtilityClassWithPublicConstructorProcessor
        extends SoraldAbstractProcessor<CtClass<?>> {

    @Override
    protected boolean canRepairInternal(CtClass<?> candidate) {
        return candidate.getConstructors().stream().allMatch(CtElement::isImplicit);
    }

    @Override
    protected void repairInternal(CtClass<?> element) {
        addExplicitConstructor(element);
    }

    @SuppressWarnings("unchecked")
    private static <T> void addExplicitConstructor(CtClass<T> cls) {
        CtConstructor<T> explicitConstructor =
                cls.getFactory()
                        .createConstructor(
                                cls,
                                Set.of(ModifierKind.PRIVATE),
                                List.of(),
                                Set.of(),
                                cls.getFactory().createBlock());
        cls.getConstructor().replace(explicitConstructor);
    }
}
